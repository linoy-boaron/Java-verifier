yahavb
linoyb96


===================
=  README for ex6 =
===================

=============================
=      File description     =
=============================
Hereinafter the files description, categorised by package:

Misc:
- README: This description file.

oop.ex6:
- PatternUtilities.java: A file that contains a utilities class for Regular Expressions.
- Token.java: A file that contains an enum used to define the tokens being used in this program.
- ValidatorFacade.java: A file that contains a facade based design pattern, used to process s-Java files.

oop.ex6.ast:
- ast/ASTNode.java: A file that contains an interface which represents a general
  node in an Abstract Syntax Tree.
- ast/ASTNodeFactory.java: A file that contains an abstract factory based class used to
  instantiate AST nodes.
- ast/ASTVisitor.java: A file that contains a visitor based design pattern interface which's being used
  to scan an AST tree.
- ast/AssignmentNode.java: A file that contains a class that implements an AST node that represents an
  assignment operation.
- ast/ConditionNode.java: A file that contains a class that implements an AST node that represents a
  single condition expression (e.g. "true", "a" etc.).
- ast/FunctionArgumentNode.java: A file that contains a class which implements an AST node that represents
  a single function declaration (callee) argument.
- ast/FunctionDeclarationNode.java: A file that contains a class which implements an AST node that represents
  a function declaration.
- ast/IfControlFlowNode.java: A file that contains a class which implements an AST node that represents
  the "if" control flow.
- ast/InvocationNode.java: A file that contains a class which implements an AST node that represents a
  function invocation.
- ast/ProgramASTNode.java: A file that contains a class which implements an AST node that represents the
  entire program.
- ast/ReturnStatementNode.java: A file that contains a class which an AST node that represents
  a return statement.
- ast/ScopeNode.java: A file that contains a class which implements an AST node that represents a
  general scope of code.
- ast/StatementNode.java: A file that contains a class which implements an AST node that represents a
  single statement.
- ast/VariableDeclarationNode.java: A file that contains a class which implements an AST node that represents
  a variable declaration.
- ast/VariableNode.java: A file that contains a class which  implements an AST node that represents a
  single variable within a variable declaration.
- ast/WhileControlFlowNode.java: A file that contains a class which implements an AST node that represents
  the "while" control flow.

oop.ex6.main:
- main/Sjavac.java: The program main entry point.

oop.ex6.parser:
- parser/CodeParser.java: A file which includes the code parser, which's a unit that translates the given
  source code, represented as a String, into an AST, by applying on it the syntax features we declared.
- parser/SyntaxErrorException.java: Defines an exception class that describes a general syntax error.

oop.ex6.parser.features:
- parser/features/AssignmentSyntaxFeature.java: A file that contains a syntax feature implementation that
  adds values assignment (w/o declarations!) support to the s-Java language.
- parser/features/BasicControlFlowSyntaxFeature.java: A file that contains a syntax feature implementation
  that adds standard control flows to the s-Java language.
- parser/features/CommentSyntaxFeature.java: A file that contains a syntax feature implementation that adds
  comments support to the s-Java language.
- parser/features/ExpressionParser.java: A file that contains a static-only class which provides parsing
  utilities for expressions.
- parser/features/FunctionDeclarationSyntaxFeature.java: A file that contains a syntax feature implementation
  that adds function declaration to the s-Java language.
- parser/features/IfControlFlowSyntaxFeature.java: A file that contains a syntax feature implementation that
  adds "if statements" support to the s-Java language.
- parser/features/InvocationSyntaxFeature.java: A file that contains a syntax feature implementation that
  adds function invocation support to the s-Java language
- parser/features/ReturnStatementSyntaxFeature.java: A file that contains a syntax feature implementation
  that adds return statements support to the s-Java language.
- parser/features/ScopeSyntaxFeature.java: A file that contains a syntax feature in the language that's being
  represented by a scope.
- parser/features/StatementSyntaxFeature.java: A file that contains a syntax feature in the language that's
  being represented in a single statement.
- parser/features/SyntaxFeature.java: A file that contains the abstraction definition of a syntax feature in
  the s-Java language. A syntax feature is a feature in the language that can be used by the programmer in
  her source code, and should be properly converted into a matching.
- parser/features/SyntaxFeatureFactory.java: A file that contains a factory-based class used to initialize
  the various, available, syntax features and made them accessible to the code parser
- parser/features/SyntaxFeatureIdentifier.java: Defines the available language syntax features.
- parser/features/SyntaxFeatureParseException.java: A file that contains a definition of the exception that's
  being raised in case of a parse error in a SyntaxFeature based class.
- parser/features/VariableDeclarationSyntaxFeature.java: A file that contains a syntax feature implementation
  that adds variable declarations (including initializing them) support to the s-Java language
- parser/features/WhileControlFlowSyntaxFeature.java: A file that contains a syntax feature implementation
  that adds "while control flows" support to the s-Java language.

oop.ex6.semantic:
- semantic/AccessUninitializedVariableException.java: A file that contains an exception definition that's
  being raised if the user tries to access an un-initialized variable.
- semantic/FunctionArgumentSymbol.java: A file that contains the definition of a symbol that represents
  a function argument.
- semantic/FunctionSymbol.java: A file that contains the definition of  symbol that represents a function.
- semantic/InvalidExpressionException.java: A file that contains the definition of a general exception that
  would be thrown if an invalid expression has been attempted to get evaluated.
- semantic/InvalidInvocationException.java: A file that contains the definition of semantic exception hat
  describes an invalid invocation attempt.
- semantic/MissingReturnStatementException.java: A file that contains the definition of a general exception
  that would be thrown if a function misses a return statement at the end of it.
- semantic/SemanticErrorException.java: A file that contains the definition of a general exception that would
  be thrown if a semantic error is detected.
- semantic/SemanticValidator.java: A file that contains the definition of a class which provides a (very
  simple) semantic validation.
- semantic/Symbol.java: A file that contains the definition of a class which represents an (abstract) symbol
  in the symbol table.
- semantic/SymbolAlreadyExistsException.java: A file that contains the definition of an exception which can
  be raised if a given symbol was already found in a symbols table.
- semantic/SymbolNotFoundException.java: A file that contains the definition of an exception that's being
  raised if a given symbol was not found found in a symbols table.
- semantic/SymbolsTable.java: A definition of a class that represents a symbol table.
- semantic/TypeNotFoundException.java: A file that contains the definition of an exception which's being
  raised if a given type was not declared.
- semantic/UninitializedFinalVariableException.java: A file that contains the definition of an exception
 that's being raised if a variable was declared as final but without actual value.
- semantic/VariableSymbol.java: A class that represents a variable symbol.

oop.ex6.types:
- types/BooleanDataType.java: A definition of a class that describes a boolean data type.
- types/CharDataType.java: A definition of a class that describes a boolean data type.
- types/DataType.java: The definition of the interface that represents a data type in the language.
- types/DoubleDataType.java: A definition of a class that describes a double data type.
- types/IntDataType.java: A definition of a class that describes an integer data type.
- types/PrimitiveDataType.java: The definition of an interface that represents a primitive data type.
- types/StringDataType.java: A definition of a class that describes a boolean data type.
- types/TypeParser.java: A definition of a class which provides parsing utilities for data types.
- types/TypeRegistry.java: A registry-based class which keep track of the declared types in the language.

=============================
=          Design           =
=============================

----- General -----
To process the sJava source files, we've chosen to use some basic algorithms and concepts related to
Compilation Theory. Precisely, We've divided the program into few steps:
1) Reading the source into a string.
2) Creating an Abstract Syntax Tree (hereinafter "AST") from the program code. This can be done by
   processing each line and checking the line syntax (w/o type or context checks).
3) Iterating over the AST and checking each AST node semantic wise. To do that, we've used a
   symbols table for both functions and variables definitions.

Initially, we wanted to follow the exact traditional path of writing a compiler, which means tokenizing
the program, creating a lexer which'll produce an AST out of the tokens and then iterate over the AST
and check for semantics. However, after the comments in the personal forum, we've decided to tweak
that design to suite better ex6 needs. Thus, we gave up on actual tokenizing and created the AST out of
the plain code lines, with regular expressions. We've named our available string to AST parsers
as "syntax features".
See: https://moodle2.cs.huji.ac.il/nu17/mod/forumng/discuss.php?d=7440 .

The process can be seen in the following diagram:

+------------+                   +-------------------+                     +------+
|Plain Source| Syntax Validation |  Abstract Syntax  | Semantic Validation |Result|
|  Code Text +------------------->Tree Representation+---------------------v------+
+------------+                   +-------------------+

----- Available Packages -----
The program was divided into packages accordingly to the above process.
1) oop.ex6: The main package. It contains the general files used to perform the process. Specifically,
   it defines a Facade that runs the code throughout the processing steps.
2) oop.ex6.main: The program main entry package.
3) oop.ex6.ast: This package defines the various type of AST nodes and other AST related algorithms.
   Each time a new feature should be added to the language, a corresponding node should be created.
4) oop.ex6.parser: This package contains the syntax code parser related code. It has a main parser class
   which iterates over the code and tries to parse it into an AST.
5) oop.ex6.parser.features: This package contains the various syntax features in the language.
   Each feature is responsible of taking a plain string and convert it into an AST node.
6) oop.ex6.semantic: This package contains the classes used to perform a semantic validation.
   Specifically, this package contains a symbol table implementation, the symbols definitions and the
   actual semantic validator.

=============================
=  Implementation details   =
=============================

----- Syntax Features: Parsing text into AST -----
The first step in the code process is to convert the code from a plain string, say "int a = 1;" into
an AST node that contains valuable information about this declaration (for example, in this case,
a node that symbolise a variable of type "int" who named "a" with "1" as its initial value).
To do that, we've defined particular parsers, we called Syntax Features. Each feature must implement
the SyntaxFeature interface, which has required methods:
1) accepts: This method takes a string and says if the parser "knows" and "should" handle it or not. Say,
   the If Statements condition wouldn't even know how to handle "int a = 1", while the variable feature does.
2) parse: This method takes that same string and process it, by creating an AST node out of it.
   This method might throw a SyntaxFeatureParseException if some un-excepted content was found.

To that explanation it's worth adding that (almost) any parser shouldn't impalement SyntaxFeature directly,
but inherit StatementSyntaxFeature OR ScopeSyntaxFeature, which means:
1) StatementSyntaxFeature: An abstract class that describes a one-line only statement. That means this line
   must end with a semi-colon, and it can't have a block of code followed after it.
2) ScopeSyntaxFeature: An abstract class that describes a scope of code. That means that this class excepts
   a curly parenthesis after the line, instead of a semicolon, and in addition it excepts to find a
   block of source code after it. It also requires to return a ScopeNode (a child of ASTNode) instead
   of a standard AST node. More on that in a second.

Note that by implementing these classes right, the CodeParser can know how to actually build the AST tree,
which node related to which statement, when scopes hasn't closed or declared correctly etc.
Finally, it does worth mentioning that each scope allows to use different syntax features in within it.
Thus, while the global scope only allows the "comment", "assignment", "variable declaration" and
"function declaration" syntax features, the FunctionDeclarationSyntaxFeature for example, which is a
child of ScopeSyntaxFeature, allows the usage of "comment", "assignment", "variable declaration",
"if control flow", "while control flow" and "invocation" syntax feature.
By this approach, we can pair specific syntax features to specific scopes.

----- Defining Abstract Syntax Tree Nodes -----
To perform the semantic check, we iterate over a tree of nodes, containing information about the program
defined data. Thus, to add a new feature, you most likely will want to define a node that will represent the
data that line contained (unless you want to discard it, say, because its a comment).
Each node must implement the ASTNode interface. That's being said, we do provide base StatementNode and
ScopeNode which you most likely need to inherit from.
It's worth mentioning again that you can't create a scope (for functions, if, while etc.) without inheriting
from scope node. This node contains a list of sub-nodes that describes the statements in this node (childs).

----- AST Visitor -----
To efficiently iterate over the different available nodes, we've implemented the Visitor Design Pattern
by creating the "ASTVisitor" interface with various "visit" overloads, each one refers to different type
of node.
See: https://en.wikipedia.org/wiki/Visitor_pattern

----- Semantic Check -----
The semantic validator implement a nested visitor(s) in order to scan the tree and analyse it. This package
also contains a Symbols table, which are tables that contains information of the current state of the
program. Thus, we've defined an abstract Symbol class, as well of a SymbolTable<T extends Symbol> classes,
whcih provide symbol table access. Then, the semantic visitors iterate over the various AST nodes, query the
symbol tables and perform actions accordingly. The semantic visitors might throw exceptions in case there's a
semantic error.

----- Data Types -----
We've created a package that contains the program data types. Each class describes a different type and
implements the DataType interface. These types are being registered with the TypeRegistry which allows to
resolve a data type by its identifier or by a given value (say, "Hello" -> String, 1 -> "int" etc.).
Note that we also created the PrimitiveDataType interface which doesnt impelement anythig special, yet, but
prepare the ground for classes integration.

----- Design Patterns -----
We've extensively used design patterns to make this program more efficient and follow the course guidelines.
Specifically, we've implemented:
1) Singletons: Each Syntax Feature, for example, was marked as a singleton, as there's no need for more than
one instance of this class, which we do want to force the developer to implement the SyntaxFeature interface.
2) Factory: The syntax features, for example, can be instantiated (by accessing the getInstance() method)
 only in their own package (we used the "default", package access modifier). To get access to the feature,
 one must use the SyntaxFeatureFactory class.
3) Abstract Factory: To create an AST node, we've used the Abstract Factory design pattern, which provide
   various methods to create the different AST nodes.
4) Visitor: As mentioned, we used the Visitor pattern to add more operations to the AST nodes, and still
follow the "close/open" principal.
5) Registry: The types are being registered with a registry class that keep track of them, and
also allows to create them (using factory method).

==================================
=  Two Main Regular expressions  =
==================================
Hereinafter two of the main regex patterns we've used:
1) Identifier:
                (?:[a-zA-Z]|_(?=[a-zA-Z0-9_]))[a-zA-Z0-9_]*
   An identifier is used to capture variables and data types. As defined in ex6 pdf, an identifier
   consisted of a-z, A-Z, 0-9 and _. That's being said, the following rules applies:
   1) First character can't be digits.
   2) If the first character is _, then the string length must be >= 2.
   Thus, we've taken the following approach:
   1) (?:[a-zA-Z]|_(?=[a-zA-Z0-9_])): As of the first digit we testing two alternatives:
    A) [a-zA-Z]: In this case, it's okay to have one letter only letter.
    B) _(?=[a-zA-Z0-9_]): The character is _, so we must have another one. Thus, we're using the
        regex "lookahead" feature (by specifying "?=" and forcing at least another character from the
        allowed groups set.
   2) [a-zA-Z0-9_]*: Another optional characters (0 or more). Note that as we used lookahead to satisfy the
        cases where "_" is the first character, we don't need to do "+" here but "*" is enough (and correct).

2) Strings Literals:
                (["])(?:(?=(\\?))\2.)*?\1
   A string must start and end with double quotes, and can contain any character within it.
   Generally, we could solve it by specifying the pattern: "([^"]*)". However, this wont satisfy
   every string case (although it's not mandatory we wanted to handle it):
        String herResponse = "She said \"Thank you!\"";
   In this case, as we used double quote again, the pattern will stop there as it got to its termination
   condition. Thus, we've used the lookahead technique to check if we find the escaping character (\).
   In case we do, we allow any character next, including quote. Then we continue till we find closing quote.

=====================================
=  Extra Feature: (2) Return Types  =
=====================================
Take, for example, the code:
<pre>
    int foo(int bar) {
        return bar + 1;
    }

    void bar() {
        int baz = foo(1);
        return;
    }
</pre>

Hereinafter the steps required to identify and support return types:

----- Create a "void" Data Type -----
Creates a new file at oop.ex6.types package named VoidType. The file should be based on this draft:
<pre>
public class VoidDataType implements PrimitiveDataType {
    private static final String TYPE_IDENTIFIER = Token.TYPE_VOID.toString();

	private VoidDataType() { }
	static VoidDataType getInstance() { /* Singleton implementation... */ }

	@Override
	public String getIdentifier() { return TYPE_IDENTIFIER; }

	@Override
	public boolean isValidValue(String value) { return false; }

	@Override
	public String getDefaultValue() { throw new NotImplementedException(); }
}
</pre>

In addition, register this type with the TypeRegistry by adding it to the static initializer:
<pre>
    register(VoidDataType.getInstance());
</pre>

----- Modify the Function Declaration Syntax Feature & AST Node -----
Open the oop.ex6.ast.FunctionDeclarationNode class and perform these changes:
1) Add a new String data field for the return type with a getter (named: returnType & getReturnType()).
2) Create an overload for the constructor that accepts data types as well.
   Note that in the overloads which doesn't take any value, one should do:
   <pre>
    this.returnType = TypeRegistry.factory(Token.TYPE_VOID.toString());
   </pre>

Open the oop.ex6.parser.features.FunctionDeclarationSyntaxFeature class and perform these changes:
2) Change the ACCEPT_PATTERN and PARSE_PATTERN, which currently accepts only
    void methods, into multiple type methods:

<pre>
	private static final Pattern ACCEPTS_PATTERN = Pattern.compile(TypeParser.formatPattern(
			"^\\s*{identifier}\\s+{method_identifier}"));

	private static final Pattern PARSE_PATTERN = Pattern.compile(TypeParser.formatPattern(
			"^\\s*{identifier}\\s+({method_identifier})\\s*\\" + Token.LEFT_PREN +
					"([^\\" + Token.RIGHT_PREN + "]*)\\" + Token.RIGHT_PREN + "\\s*\\"
					+ Token.LEFT_CURLY_PREN + "\\s*$"));
</pre>
Note the usage of "{identifier}" and "{method_identifier}". These are some special identifiers being
recognised by TypeParser.formatPattern(String), which being replaced by a regular expression definitions:
- Identifier: ([a-zA-Z]|_(?=[a-zA-Z0-9_]))[a-zA-Z0-9_]*
- Method Identifier: ([a-zA-Z])[a-zA-Z0-9_]*

2) At the parse(String) method, catch this group and send it to the FunctionDeclarationNode.
   Note that at this point we don't check if this value exists. The only that we know is that it matches
   the identifier pattern thus it's not invalid sequence (e.g. "1A foo()", "!!! foo()" etc.).

----- Modify the Return Statement Syntax Feature & AST Node -----
Open the oop.ex6.ast.ReturnStatementNode class and perform these changes:
1) Add a new field named "returnValue" and a getter to that field as well.
2) Add an overload for the function that takes a return value.

Open the oop.ex6.parser.features.ReturnStatementSyntaxFeature class and perform these changes:
1) Modify the ACCEPTS_PATTERN and create a PARSE_PATTERN:
<pre>
private static final Pattern ACCEPT_PATTERN = Pattern.compile("^\\s*" + Token.RETURN);
private static final Pattern PARSE_PATTERN = Pattern.compile(TypeParser.formatPattern(
			"^\\s*" + Token.RETURN + "\\s*({identifier})?\\s*" + Token.SEMICOLON + "\\s*$"));
</pre>

2) Change the accept method to use the find() method instead of matches() as we only aim to match
    the beginning of the line now. Then, do "return m.start() == 0" to make sure the matches is indeed
    in the first character of the string.

3) Modify the parse method to match the entire PARSE_PATTERN (using Matcher#matches()). Then, check whether
   or not we got a return type and based on that return a new ReturnStatementNode.

----- Modify the Assignment and Declaration of variables -----
To support assigning function results to variable (int a = foo(), for example), then we need to modify
oop.ex6.parser.AssignmentSyntaxFeature, oop.ex6.parser.VariableDeclarationSyntaxFeature,
oop.ex6.ast.AssignmentNode and oop.ex6.ast.VariableNode:
1) oop.ex6.ast.AssignmentNode and oop.ex6.ast.VariableNode: Add new, optional, InvocationNode field. In
   addition, create an overload to the constructor that gets this InvocationNode instead of String that
   describes the value sent to the function. Obviously, allow to access this InvocationNode using getter.
2) oop.ex6.parser.AssignmentSyntaxFeature, oop.ex6.parser.VariableDeclarationSyntaxFeature:
   After analysing the two operands of the assignment (e.g. {left} = {right}), get the instance of the
   InvocationSyntaxFeature from the SyntaxFeatureFactory and send the {right} value to the accepts(String)
   method. It'll tell if this is an actual function invocation. If it does, apply the parse(String) method
   to get the InvocationNode.
   The actual creation of AssignmentNode should be depend of whether or not we have an invocation node / not.
   If we do - send it, otherwise, use the plain string.
   P.S. The InvocatioNnode will handle invalid function calls, such as int a = foo(1));.

----- Modify the Invocation Syntax Feature & AST Node -----
To support nested function calls "e.g. foo(bar(baz(1)))", do these steps:
Open oop.ex6.ast.InvocationNode:
A) Add a new field of nested invocation (List<InvocationNode> innerInvocations).
B) Add getter fot this field, as well as constructor overload and an append(InvocationNode) method.
C) Create this helper method, that determines how much arguments the function totally accepts:
   <pre>
    public int getTotalArgumentsCount() {
        return this.arguments.size() + this.innerInvocations.size();
    }
   </pre>

Open oop.ex6.ast.InvocationSyntaxFeature:
A) Before the line:
   <pre>
    List<String> args = ExpressionParser.parseCallerArguments(argsString);
   </pre>
   Declare a list of InvocationNode (named, for example, innerInvocations).
B) After the line mentioned in (A), which separate the arguments and make sure they're validly supplied
   (e.g. not foo(1,,,3), iterate on this list and invoke InvocationNode#accept(String) on each node.
   If it returns true, then perform a recursive call to InvocationNode#parse(String) and add the result
   to the innerInvocations list.
C) Finally, create the InvocationNode from both the old, List<String> args and from the new innerInvocations.

----- Modify the Semantic Validator -----
Finally, Open the oop.ex6.semantic.SemanticValidator class and perform these changes:
1) At the GlobalScopeVisitor, modify the visit(FunctionDeclarationNode) variation and make sure
   that the return type is valid. If not, throw an exception. That can be done simply by
   calling: TypeRegistry.isRegistered(node.getReturnType()).
2) At GeneralSemanticVisitor, perform these modifications:
   A) Create local field named "FunctionSymbol currentFunction" which'll store the current fucntion.
      We'll use this field to validate the return type. Note that as it's single variable we won't be able
      to nest functions. To allow that - we could've just use Stack<FunctionSymbol>.
   B) visit(FunctionDeclarationNode): Just after we push the variables to the symbols table, and before we
      actually performing the node children visiting, we should assign the currentFunction field to the node.
      After the loop, we should put this field as null.
   C) visit(ReturnStatementNode): This method doesn't exists in the current implementation as we don't need
      it. We should implement it and do the following:
      1) If the currentFunction field is null - throw an exception as this statement used w/o function.
         (though it shouldn't even happen cause this casues a syntax error).
      2) Make sure that the return type of the function matches the return type given in the statement.
         If currentFunction.getReturnType() is void, then we need to check for null value in the return
         statement node. Otherwise, we need to check if the returned variable is a constant or variable.
         If it's a constant: we can use TypeRegistry#resolveFromValue(String) to get the actual type it
         belongs to. Otherwise, we should check if it's a valid identifier with TypeParser#isIdentifier,
         then make sure it was declared before and get its type. Finally, we should use the method
         DataType#canCreateFrom(DataType) to make sure the FUNCTION return value can be created from the
         value defined at the return statement.
         You can see a very similar implementation to these steps in both the assignment and the
         invocation nodes.
   D) visit(AssignmentNode): Instead of calling "if (!this.canAssignValue(symbol, node.getValue())) {",
      which makes sure the value matches matches the given variable, check if the node contains a
      InvocationNode or a value. If it's a value - continue with the old approach. If it's an
      InvocationNode, just use the InvocationNode#accept(ASTVisitor) method to make sure its valid.
   E) handleVariableDeclaration(VariableNode): Follow the instructions applied on the assignment operation,
      regarding the validation of invocations - which means that if the node contains an invocation instead
      of raw value (literal or variable) - use InvocationNode#accept(ASTVisitor) instead.
      That'll handle everything needed, including recursive calls like int a = pow(add(1, 1), 2);
   F) visit(InvocationNode): Perform these changes:
        1) Instead of the line "int len = symbolArguments.size();", call the function
        we've declared before, "symbolArguments.getTotalArgumentsCount()".
        2) After the standard loop of the "standard" arguments (literals and variable), perform
        another loop on the inner invocation and recursively accept them with the AST Visitor:
        <pre>
            for (InvocationNode innerInvocation : symbolArguments.getInnerInvocations()) {
                innerInvocation.accept(this);
            }
        </pre>

And... That's it! :)

============================================
=  Extra Feature: (4) Inheritance of files =
============================================
Consider the following code:

foo.sjava:
<pre>
    int a = 1;
    void foo() {
        // Some cool code...
        return;
    }
    void foo2() {
        // Another cool code...
        return;
    }
</pre>

bar.sjava:
<pre>
    import "./modules/foo.sjava";
    void bar() {
        a = 2;
        foo();
        return;
    }
</pre>

ASSUMPTIONS:
1) To import file one should use the "import" keyword.
2) The imported clause should be a valid file path.
3) As it's files inheritance, we does not allow recursive importations.

The following changes should be made to make inheritance of files possible:

----- Define the "import" token -----
Modify oop.ex6.Token class so it'll have:
<pre>
IMPORT() {
        @Override
        public String toString() {
            return "import";
        }
    }
</pre>

----- Adding an "import" syntax feature -----
In oop.ex6.parser.features, Create a new ImportSyntaxFeature.java file, which does the following:
1) The class inherit from StatementSyntaxFeature.
2) The class defines the following pattern:
   <pre>
    private static final Pattern PARSE_PATTERN = Pattern.compile(TypeParser.formatPattern(
        "^\\s*" + Token.IMPORT + "\\s*{string}\\s*" + Token.SEMICOLON + "\\s*$"));
   </pre>
   (Note again the usage of formatPattern which translates this expression to:
   ^\s*import\s*(["])(?:(?=(\\?))\2.)*?\1\s*;\s*$

3) Implement the boolean accept(String) method in a way that it'll trim all spaces from the line and check if
   it can find the import keyword and then one clause. Thats our only check for the feature accept condition.
4) Implement the ASTNode parse(String) method as follows: Evaluate the PARSE_PATTERN on the line and try to
   extract the imported file. If it doesn't work - throw a SyntaxFeatureParseException. Then, simply return
   a ImportNode by calling ASTNodeFactory.createImportNode(importedFile).

----- Adding an "import" AST support -----
In oop.ex6.ast create ImportNode.java and define the ImportNode class:
1) The class should inherit StatementNode.
2) The class should have a "modulePath" property (a.k.a. private final field + getter).
3) Create a package-default accessed constructor that takes the module name.
4) Import the accept(ASTVisitor) abstract method by simply send the visitor "this".

Open oop.ex6.ast.ASTNodeFactory and define the method:
<pre>
   public ImportNode createImportNode(String moduleName) {
        if (moduleName == null) throw new NullPointerException();
        return new ImportNode(moduleName);
   }
</pre>

Open oop.ex6.ast.ASTVisitor and support the ImportNode by adding:
<pre>
	default void visit(ImportNode node) { }
</pre>

----- Modify the semantic validator -----
Currently we can use the "import" keyword and it got translated into an AST node. Now we need to semantically
check it and apply it on the actual semantic validation (a.k.a, read the nested tree, define the parent
methods and so on). Open oop.ex6.semantic.SemanticValidator and do the following:
1) Add another overload to assertValidity so it'll look like:
<pre>
    public void assertValidity()
    		throws SemanticErrorException {
        assertValidity(this.root);
    }

    public void assertValidity(ASTProgramNode root)
    		throws SemanticErrorException {
        // The current implementation, but use the argument root instead of "this.root".
    }
</pre>
Also change the actual implementation of the catch block so it'll catch IOException as well.
2) To the GlobalScopeVisitor nested class, add:
<pre>
    private final Stack<String> modulesStack = new Stack<String>();

    private String String readModuleName(String modulePath)
        throws IOException {
        File sourceFile = new File(modulePath);
        if (!sourceFile.exists()) {
            throw new FileNotFoundException();
        }

        BufferedReader buffer = new BufferedReader(new FileReader(sourceFile));
        StringBuilder builder = new StringBuilder();
        String line;

        while ((line = buffer.readLine()) != null) {
            builder.append(line).append("\n");
        }

        return builder.toString();
    }
    public void visit(ImportNode node) {
        String modulePath = node.getModulePath();
        if (modulesStack.contains(modulePath) {
            throw new InvalidStateException(new RecursiveImportException(modulePath);
        try {
            // Get the module source code
            String moduleSourceCode = readModuleName(modulePath);

            // Parse it
            ProgramASTNode moduleTree = new CodeParser().parse(sourceCode);

            // Recursively process the tree
            this.modulesStack.push(modulePath);

            assertValidity(moduleTree); // << Note that this is a parent class method.

            this.modulesStack.pop(modulePath);
        } catch (IOException e1) {
            throw new IllegalStateException(String.format("An I/O error occurred while reading the module"
                + " %s.", modulePath), e1);
        } catch (SyntaxFeatureException e2) {
            throw new IllegalStateException(String.format("A syntax error found while processing the module"
                + " %s.", modulePath), e2);
        }
    }
</pre>
3) We've used the "modulesStack" to avoid recursive inclusions. The only missing module, though, we haven't
   included is the main module. We will allow to use the semantic in two ways: A) Execute raw code, which we
   don't treat as being read from file (like, standard code string); B) A code file that was read.
   Thus, we'll change the class constructor to the following:
   <pre>
   	public SemanticValidator(ProgramASTNode root) {
        this(root, null);
    }

	public SemanticValidator(ProgramASTNode root, String modulePath) {
		this.root = root;
		this.functionsSymbolTable = new SymbolsTable<>();
		this.variablesTable = new SymbolsTable<>();

		if (modulePath != null) {
		    this.modulesStack.push(modulePath); // << Note this addition
		}
	}
	</pre>

	Now the developer can choose to supply a main module or not. We do need, now, to change the facade
	so it'll send the module file into this class.
	Thus, open oop.ex6.ValidatorFacade and:
	A) Modify validateSourceCode(String) to this draft:
	<pre>
	    public void validateSourceCode(String sourceCode)
	        throws SyntaxErrorException, SemanticErrorException{
	        validateSourceCode(sourceCode, null);
	    }
	    public void validateSourceCode(String sourceCode, String modulePath) {
	        throws SyntaxErrorException, SemanticErrorException {
            // The old syntax-parsing code...

            /* Make sure the program is valid semantic-wise */
            new SemanticValidator(tree, modulePath).assertValidity(); // << Note the addition of modulePath
        }
	</pre>
    B) Send the main module from validateFile(String):
    <pre>
        public void validateFile(String sourceFile)
            throws IOException, SyntaxErrorException, SemanticErrorException {
            if (sourceFile == null) throw new NullPointerException();
            this.validateSourceCode(readSourceFile(sourceFile), sourceFile); // << Note the added sourceFile
        }

    </pre>

Finally, declare RecursiveImportException in the semantic package. It should inherit the
SemanticErrorException and implement the parent constructors. It also need to include a "modulePath" property
and receive in the constructor overloads.

And that'll complete our implementation! :)


NOTE FOR BOTH IMPLEMENTATIONS: We've tried to balance between given as correct and broad answer as possible,
but without referring to too much little implementation details. We hope that this satisfy the "explain the
way you'd do it but you're not required to write an actual implementation" guidelines.
Obviously, in real implementation, we'd use constants when needed, provide documentations etc.

Thanks for reading :)!